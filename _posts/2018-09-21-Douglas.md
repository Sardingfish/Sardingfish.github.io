---
layout: post
title:  "Douglas-Peucker algorithm for image compression"
date:   2018-09-21
categories: Program
tags: Algorithm
---



**Algorithm interpretation**

起始曲线是一组有序的点或线，距离尺寸*ε*> 0。

该算法递归地划分该行。最初，它给出了第一个点和最后一个点之间的所有点。它会自动标记要保留的第一个和最后一个点。然后它找到距离线段最远的点，其中第一个点和最后一个点作为终点;这一点在曲线上距离端点之间的近似线段明显最远。如果该点比线段更接近*ε*，则可以丢弃当前未标记为保留的任何点，而简化曲线不比*ε*差。

如果距离线段最远的点距离近似值大于*ε*则必须保持该点。算法以第一个点和最远点递归调用自身，然后用最远点和最后一个点调用自身，其中包括最远点标记为保留。

当递归完成时，可以生成新的输出曲线，该曲线包括所有且仅有那些已标记为保留的点。



**Vedio Demo**

![](https://raw.githubusercontent.com/Sardingfish/Sardingfish.github.io/master/image/2018-09-21-Douglas/Douglas-Peucker_animated.gif)



**Calculation steps**

*Part I*

判断点是否保留返回应保留点点号

1.读入点d[i],d[j],若j-i==1,转到7,若否,转到2;

2.计算过点P[i]和点P[j]的直线Ax+By+C=0;

3.根据点到直线距离公式计算P[i+1],P[i+2]...P[j-1]到直线的距离d[xx];

4.排序选出最大值d[k];

5.若d[k]>D(阈值),返回k,结束;

6.若d[k]<D(阈值),转到7;

7.返回0,结束;

 

*Part II*

生成应保留点链表函数

1.将第一点p[1]与最后一点p[n]写入链表.p[1]指向p[n],p[n]指向NULL,当前指针p指针指向p[1];

2.判断p->next是否指向NULL,若是,转到6;若否,转到3;

3.将p与p->next代入函数PartI,获得返回值R;

4.若R==0,p=p->next,转到2;

5.若R！=0,将p[R]插入链表到p与p->next之间,转到2;

6.结束.



**Code display**

```c++
	struct node
	{
        int num;                                      //point number
	    struct node *next;
    };
	int  m=sen;
    struct node *head;                                //header pointer
    struct node *pd;                                  //current pointer
    struct node *end;                                 //footer pointer
    struct node *new1;                                //new node

	head=(struct node*)malloc(sizeof(struct node));   
	head->num=0;                                      
    pd=head;                                           
	end=(struct node*)malloc(sizeof(struct node));  
	end->num=m-1;        
	head->next=end;
	end->next=NULL;

	while(pd->next!=NULL)
	{
		if(Douglas(point,pd->num,pd->next->num)!=0)
		{
        new1=(struct node*)malloc(sizeof(struct node)); 
        new1->num=Douglas(point,pd->num,pd->next->num);
		new1->next=pd->next;
		pd->next=new1;
		}
		else
			pd=pd->next;
	}

	pd=head;
```

```c++
int Douglas(double *p[], int n1, int n2)
{
	if(n2-n1==1)
		return 0;
	int n;                      //Maximum distance corresponding to the point number
	double d,dmax=0;            //Point to straight line distance
	double A,B,C;               //Calculated two straight line coefficients
	double D=3;                 //Threshold
	A=p[n1][1]-p[n2][1];                 
	B=p[n2][0]-p[n1][0];                 
	C=p[n1][0]*p[n2][1]-p[n2][0]*p[n1][1];   
	
	for(int i=n1+1;i<n2;i++)
	{
		d=fabs(A*p[i][0]+B*p[i][1]+C)/sqrt(A*A+B*B);             
		if(d>dmax)
		{
			dmax=d;
			n=i;
		}
	}

if(dmax>D)
   return n;
else 
   return 0;
}
```

